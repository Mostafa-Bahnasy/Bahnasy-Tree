it is my own DS, and the description is as follow:
need:
it solves the range query problem + inserting and deleting in any part of the sequence of data and keep the other quires time good. you may imagine it do the same tasks as treap, or it is a segment tree with ability to insert elements to the array and solve quires online.

Structure:
Simple structure:
We have two main values: spf(S), threshold(T)
each node will represent spf branches

and each node maximum hold T values, T = cubic(n) ( I will stress test the best T value later)
The following condition must follow for each node when building the tree:
- S <= T for each node, or assume S = 2 if the S is bigger than T.
- S represnets the number of child nodes for the current node, and the data is divided evenly between each child node, and any shortage is put in the last node.

When building, we keep split our current node and construct sizes of the children till we reach the base case (S <= T), so they are our leaf nodes.

I can carry any info for each node, as each node represents a range of indices or nodes.

There will be some operations allowed:
- build: it build our tree on a given input array.
- upd/get: set or get value of some index or range.
- get index: it searches for some leaf node, by exculding sizes.
- insert: it searches for the node where i will insert myself as a child to, and update the size and check this node condition(S <= T), and if it is not apply, we reorganize the node, we consider there are new level in the middle, where we replace the previous children of the node with a mid layer to ensure the condition is hold, this operation is done in the node above the leaf only, we do not update structure if all the upper nodes.
- delete: delete some node by knowing its index.

There are two imlpementation i wrote for some problems in cses(they got accepted), with no insert/delete functions yet:

```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define int long long
 
const int Threshold = 100   ;
 
const int N = 2e5+10;
int arr[N];
 
struct Node {
    vector<Node*>chld;
    int sz=0;
    int data=0;
    int L, R;
    
    Node(int sz, int l,int r) {
        //chld.resize(sz, nullptr);
        this->sz = sz;
        data = 0;
        L = l, R = r;
 
    }
 
    void split() {
        // base
        if (sz <= Threshold) {
            
            for (int i = L; i <= R; i++)
                data += arr[i];
            return;
        }
 
        //int nn = n;
        int spf = sz;
        for (int i = 2; i * i <= sz; i++) {
            if (sz % i == 0) {
                spf = i; break;
            }
 
        }
 
        if (spf > Threshold) {
            sz++;
            spf = 2;
        }
        // 1 -> 5, 2, 
 
        int nw_size = sz / spf;
 
        for (int i = 0; i < spf; i++) {
            chld.push_back(new Node(nw_size, L + nw_size * i, min(R, L + nw_size * (i + 1) - 1)));
            chld.back()->split();
            this->data += chld.back()->data;
        }
    }
 
    int get(int l, int r) {
        if (l > R or r < L)return 0;
        if (l <= L and R <= r)return data;
 
        int ret = 0;
 
        if (this->chld.empty()) {
 
            for (int i = L; i <= R; i++) {
                if (l <= i and i <= r)ret += arr[i];
            }
        }
        else {
            for (auto& ch : this->chld) {
 
                ret += ch->get(l, r);
            }
        }
        return ret;
    }
 
};
 
 
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
 
 
    int n,q;
    cin >> n>>q;
 
    for (int i = 1; i <= n; i++)cin >> arr[i];
 
    Node* root = new Node(n, 1, n);
 
    root->split();
 
    while (q--) {
 
        int l, r;
        cin >> l >> r;
 
        cout << root->get(l, r) << "\n";
    }
 
}
```

```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define int long long
 
const int Threshold = 3   ;
 
const int N = 2e5+10;
int arr[N];
 
struct Node {
    vector<Node*>chld;
    int sz=0;
    int data=0;
    int L, R;
    
    Node(int sz, int l,int r) {
        //chld.resize(sz, nullptr);
        this->sz = sz;
        data = 0;
        L = l, R = r;
 
    }
 
    void split() {
        // base
        if (sz <= Threshold) {
            
            for (int i = L; i <= R; i++)
                data += arr[i];
            return;
        }
 
        //int nn = n;
        int spf = sz;
        for (int i = 2; i * i <= sz; i++) {
            if (sz % i == 0) {
                spf = i; break;
            }
 
        }
 
        if (spf > Threshold) {
            sz++;
            spf = 2;
        }
        // 1 -> 5, 2, 
 
        int nw_size = sz / spf;
 
        for (int i = 0; i < spf; i++) {
            chld.push_back(new Node(nw_size, L + nw_size * i, min(R, L + nw_size * (i + 1) - 1)));
            chld.back()->split();
            this->data += chld.back()->data;
        }
    }
 
    int get(int l, int r) {
        if (l > R or r < L)return 0;
        if (l <= L and R <= r)return data;
 
        int ret = 0;
 
        if (this->chld.empty()) {
 
            for (int i = L; i <= R; i++) {
                if (l <= i and i <= r)ret += arr[i];
            }
        }
        else {
            for (auto& ch : this->chld) {
 
                ret += ch->get(l, r);
            }
        }
        return ret;
    }
 
    void upd(int pos,int val) {
        if (L > pos or pos > R)return ;
        if (L<=pos and pos <=R and this->chld.empty()) {
            int delta = val - arr[pos];
            data += delta;
            arr[pos] = val;
            return;
        }
 
        data = 0;
        for (auto& ch : chld) {
            ch->upd(pos, val);
            data = data + ch->data;
        }
    }
};
 
 
 
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
 
 
    int n,q;
    cin >> n>>q;
 
    for (int i = 1; i <= n; i++)cin >> arr[i];
 
    Node* root = new Node(n, 1, n);
 
    root->split();
 
    while (q--) {
 
        int op;
        cin >> op;
        if (op == 2) {
            int l, r;
            cin >> l >> r;
 
            cout << root->get(l, r) << "\n";
        }
        else {
            int pos, val;
            cin >> pos >> val;
            root->upd(pos, val);
        }
    }
 
}
```
Now, I try to write a generic code that i can post in blog with a tutorial for this DS, or to publish anyways. There is my implementation with insert, but it is not tested yet, complete the implenetation abd give me recommenditions, and add delete function as well. 

```cpp
#include<bits/stdc++.h>


using namespace std;



class Node{
public:
    // Member variables
    int node_size;
    vector<Node*> children;
    int data;
    Node* parent; 
    
    // Constructors
    Node(Node*par, int size){
        this->node_size = size;
        this->data = 0;
        parent = par;
    }
    Node(){
        this->node_size = 0;
        this->data = 0;
        this->parent = nullptr;
    }
    Node(const Node &other){
        this->node_size = other.node_size;
        this->data = other.data;
        this->children = other.children;
    }
    Node(int size,int data){
        this->node_size = size;
        this->data = data;
    }


    // Member functions


    void split(int threshold){
        //base case
        if(this->node_size <= threshold){
            for(int i = 0;i<this->node_size;i++){
                Node *child = new Node(this, 1);
                this->children.push_back(child);
            }
            return;
        }


        // spf part can be optimized 
        int spf = (this->node_size%2)?-1:2;
        for(int i = 3;i*i<this->node_size and spf!=-1;i+=2){
            if(this->node_size %i==0){
                spf = i;
            }
        }
        if(spf==-1 or spf>threshold)spf = 2;
        int group_sz = this->node_size /spf;
        for(int i = 0 ;i<spf-1;i++){
            int L = group_sz *i + 1;
            int R = min(this->node_size, (i+1)*group_sz);            
            Node *child = new Node(this, R-L+1);
            child->split(threshold);
            this->children.push_back(child);
        }
    }


    void relax(Node*node, int idx,int threshold){
        //base case
        if(this->node_size <= threshold){
            Node *child = new Node(this,1);
            this->children.insert(this->children.begin()+(idx - 1),child);
            return;
        }


        // spf part can be optimized 
        int spf = (this->node_size%2)?-1:2;
        for(int i = 3;i*i<this->node_size and spf!=-1;i+=2){
            if(this->node_size %i==0){
                spf = i;
            }
        }
        if(spf==-1 or spf>threshold)spf = 2;
        int group_sz = this->node_size /spf;


        vector<Node*>new_children(spf);


        for(int i = 0;i<this->children.size();i++){
            Node * cur = this->children[i];
            cur->parent = new_children[i%spf];
            new_children[i%spf]->children.push_back(cur);
            // new_children[i%spf]->children.push_back(Node(this->children[i]));
        }


        for(int i = 0;i<spf;i++)new_children[i]->node_size = new_children[i]->children.size();


        this->children = new_children;
    }


    void insert(int idx,int threshold){
        if(this->node_size==1){
            // leaf, insert to its parent
            relax(parent, idx,threshold);
        }
        this->node_size++;
        for(int i = 0;i<children.size();i++){
            if(idx>children[i]->node_size)idx-=children[i]->node_size;
            else{
                return children[i]->insert(idx,threshold),void();
            }
        }
        relax(this, idx,threshold);
    }


    int find(int idx){
        
        if(idx>this->node_size or idx<1)return -1;
        // this loop can be optimized with o(1)
        for(int i  =0;i<children.size(); i++){
            if(children[i]->node_size<idx){
                idx-=children[i]->node_size;
            }
            else{
                return children[i]->find(idx);
            }
        }
        return this->data;
    }
};


class BahnasyTree{
    int Threshold;
    int size;
    Node *root;
public:
    BahnasyTree(int size){
        this->Threshold = (int)cbrt(size);
        this->size = size;
        this->root = nullptr;


    }
    void buildTree(){
        // Implementation for building the tree
    }
};


signed main(){


}
```


Complexity analysis(revise this after me):

- when building the tree it is just O(N log(N)), and get/set/find/delete quires are O(log(N) + T), which is O(T) if we assume it is bigger.

- The insert function is somehow tricky, to find the node we insert in, and update its structure, it takes O(log(N) + T), but after many insertions in the same leaf node, our tree level will increase by one, how? consider we need to insert to a node with T children, the new size now is T+1, so in the worst case we will split the node to new two halves, Left(T+1), Right(remaining childs), so now we added a new mid layer of childs, so the maximum depth of the tree now is increased by one. so the log(N) is now in worst case log(N) +1, consider the depth is called D. Now, we have left and right node each with T/2 size, so if i need to increase the tree depth by 1 again, i need to insert T/2 new nodes in the same place(left or right node), so we can say in worst case after each T/2 insertion in the same place, it will increase D by one.

When the D will equal to T?
- we know D is initially = log, and after T/2 operations in the same place it increases by 1, so:
- need = T - D.
- need = T - log(N)
- need operations = T(T - log(N))/2

in terms of time complexity we can remove some constants, as log is constant actually and low, and the division by 2, we will delete them.
so the time needed to have T levels is: T*T.


it is still good, as any operation is still O(T). but what i think about is to reshape or rebuild the entire tree from scratch it takes O(N log N), but when the D is over some value which cause the time to be bad. I do not know what is the value, what do u think?